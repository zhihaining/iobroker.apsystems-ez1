"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.escapeRegExp = escapeRegExp;
exports.padRight = padRight;
exports.error = error;
exports.die = die;
exports.getIndentation = getIndentation;
exports.getFileIndentation = getFileIndentation;
exports.interceptErrors = interceptErrors;
const ansi_colors_1 = require("ansi-colors");
const promises_1 = require("node:fs/promises");
/**
 *
 */
function escapeRegExp(value) {
    return value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
}
/**
 *
 */
function padRight(text, totalLength) {
    return text.padEnd(totalLength, " ");
}
/**
 *
 */
function error(message) {
    console.error(ansi_colors_1.bold.red(message));
    console.error();
}
/**
 *
 */
function die(message) {
    console.error((0, ansi_colors_1.red)(message));
    process.exit(1);
}
/**
 *
 */
function getIndentation(text) {
    const lines = text.split(/\r?\n/);
    const fileStartLine = lines.findIndex(line => line.startsWith("{"));
    if (fileStartLine !== -1 && lines.length > fileStartLine + 1) {
        // Check for tabs first
        const tabMatches = lines[fileStartLine + 1].match(/^\t+/);
        if (tabMatches && tabMatches.length >= 1) {
            return "\t";
        }
        // Check for spaces
        const spaceMatches = lines[fileStartLine + 1].match(/^[ ]+/);
        if (spaceMatches && spaceMatches.length >= 1) {
            return spaceMatches[0].length;
        }
    }
    return 4;
}
/**
 *
 */
async function getFileIndentation(filePath) {
    try {
        const content = await (0, promises_1.readFile)(filePath, "utf-8");
        return getIndentation(content);
    }
    catch {
        // If file doesn't exist or can't be read, use default (4 spaces)
        return 4;
    }
}
/**
 *
 */
function interceptErrors(func) {
    return async () => {
        try {
            await func();
        }
        catch (error) {
            die(error.stack || error);
        }
    };
}
//# sourceMappingURL=util.js.map