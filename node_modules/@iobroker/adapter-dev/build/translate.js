"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RateLimitedError = exports.TranslationSkippedError = void 0;
exports.resetRateLimitState = resetRateLimitState;
exports.clearTranslationCache = clearTranslationCache;
exports.getRateLimitState = getRateLimitState;
exports.setRateLimitState = setRateLimitState;
exports.translateText = translateText;
const translators_1 = require("./translators");
const util_1 = require("./util");
const translationCache = new Map();
// Rate limiting state
let isRateLimited = false;
let rateLimitRetryAfter;
/**
 * Custom error class thrown when translation is skipped due to rate limiting
 */
class TranslationSkippedError extends Error {
    constructor(targetLang, retryAfter) {
        const retryMessage = retryAfter
            ? ` (retry after ${retryAfter} seconds)`
            : "";
        super(`Skipping translation to "${targetLang}" due to rate limiting${retryMessage}`);
        this.name = "TranslationSkippedError";
        this.retryAfter = retryAfter;
    }
}
exports.TranslationSkippedError = TranslationSkippedError;
/**
 * Custom error class for rate limiting and quota exceeded errors
 */
class RateLimitedError extends Error {
    constructor(message, retryAfter, headers) {
        super(message);
        this.name = "RateLimitedError";
        this.response = { status: 429, headers };
        this.retryAfter = retryAfter;
    }
}
exports.RateLimitedError = RateLimitedError;
/**
 * Resets the rate limiting state. Useful for testing or when starting a new translation session.
 */
function resetRateLimitState() {
    isRateLimited = false;
    rateLimitRetryAfter = undefined;
}
/**
 * Clears the translation cache. Useful for testing.
 */
function clearTranslationCache() {
    translationCache.clear();
}
/**
 * Gets the current rate limiting state. Useful for testing.
 */
function getRateLimitState() {
    return { isRateLimited, rateLimitRetryAfter };
}
/**
 * Sets the rate limiting state. Useful for testing.
 */
function setRateLimitState(rateLimited, retryAfter) {
    isRateLimited = rateLimited;
    rateLimitRetryAfter = retryAfter;
}
/**
 * Translates text using the Google Translate API.
 *
 * @param text The text to translate
 * @param targetLang The target language code
 * @param key Optional key name for better error reporting
 * @returns The translated text
 * @throws {TranslationSkippedError} When translation is skipped due to rate limiting
 */
async function translateText(text, targetLang, key) {
    var _a, _b, _c;
    if (targetLang === "en") {
        return text;
    }
    // Handle empty strings with specific error message
    if (text.trim() === "") {
        const keyInfo = key ? ` for key "${key}"` : "";
        const message = `Could not translate to "${targetLang}"${keyInfo}: Empty source text. Consider providing default text or the UI can display the key name as fallback.`;
        (0, util_1.error)(message);
        return text;
    }
    // Try to read the translation from the translation cache first
    if (!translationCache.has(targetLang)) {
        translationCache.set(targetLang, new Map());
    }
    const langCache = translationCache.get(targetLang);
    // Return cached translation if available
    if (langCache.has(text)) {
        return langCache.get(text);
    }
    // Skip new translation requests if we're rate limited
    if (isRateLimited) {
        throw new TranslationSkippedError(targetLang, rateLimitRetryAfter);
    }
    // Fall back to an online translation
    const translator = await getTranslator();
    let translated;
    try {
        translated = await translator.translate(text, targetLang);
    }
    catch (e) {
        // Check if this is a rate limiting error
        if (e instanceof RateLimitedError || ((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 429) {
            // Set rate limiting state
            isRateLimited = true;
            // Extract retry-after from RateLimitedError or headers
            let retryAfter;
            if (e instanceof RateLimitedError && e.retryAfter) {
                retryAfter = e.retryAfter;
            }
            else if ((_c = (_b = e.response) === null || _b === void 0 ? void 0 : _b.headers) === null || _c === void 0 ? void 0 : _c["retry-after"]) {
                retryAfter = parseInt(e.response.headers["retry-after"], 10);
            }
            rateLimitRetryAfter = retryAfter;
            // Throw TranslationSkippedError for rate limiting
            throw new TranslationSkippedError(targetLang, rateLimitRetryAfter);
        }
        const keyInfo = key ? ` for key "${key}"` : "";
        const message = `Could not translate to "${targetLang}"${keyInfo}: ${e.message || e}. The UI can display the original text or key name as fallback.`;
        (0, util_1.error)(message);
        return text;
    }
    langCache.set(text, translated);
    return translated;
}
async function createTranslator() {
    if (process.env.TESTING) {
        console.log("Using dummy testing translation");
        return new translators_1.TestingTranslator();
    }
    if (process.env.DEEPL_API_KEY) {
        const deeplTranslator = new translators_1.DeeplTranslator();
        try {
            await deeplTranslator.init();
            console.log("Using DeepL Translate");
            return deeplTranslator;
        }
        catch (err) {
            (0, util_1.error)(err);
        }
    }
    if (process.env.GOOGLE_APPLICATION_CREDENTIALS) {
        const v3 = new translators_1.GoogleV3Translator();
        try {
            await v3.init();
            console.log("Using Google Translate V3");
            return v3;
        }
        catch (err) {
            (0, util_1.error)(err);
        }
    }
    console.log("Using Legacy Google Translate");
    return new translators_1.LegacyTranslator();
}
let creator = undefined;
function getTranslator() {
    if (!creator) {
        creator = createTranslator();
    }
    return creator;
}
//# sourceMappingURL=translate.js.map