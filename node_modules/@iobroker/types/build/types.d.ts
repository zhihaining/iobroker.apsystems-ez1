import type { CommandResult } from '@alcalzone/pak';
import { EventEmitter } from 'node:events';

/**
 * Polyfill to allow calling without `new`
 */
export declare const Adapter: typeof AdapterClass;

/**
 * Here we define dynamically created methods
 */
export declare interface AdapterClass {
    on(event: 'stateChange', listener: ioBroker.StateChangeHandler): this;
    on(event: 'objectChange', listener: ioBroker.ObjectChangeHandler): this;
    on(event: 'fileChange', listener: ioBroker.FileChangeHandler): this;
    on(event: 'ready', listener: ioBroker.ReadyHandler): this;
    on(event: 'install', listener: ioBroker.ReadyHandler): this;
    on(event: 'unload', listener: ioBroker.UnloadHandler): this;
    on(event: 'message', listener: ioBroker.MessageHandler): this;
    /** Only emitted for compact instances */
    on(event: 'exit', listener: (exitCode: number, reason: string) => Promise<void> | void): this;
    on(event: 'log', listener: (message: ioBroker.LogMessage) => Promise<void> | void): this;
    /**
     * Extend an object and create it if it might not exist
     *
     * @deprecated use `adapter.extendObject` without a callback instead
     */
    extendObjectAsync(id: string, objPart: ioBroker.PartialObject, options?: ioBroker.ExtendObjectOptions): ioBroker.SetObjectPromise;
    /** Set the capabilities of the given executable. Only works on Linux systems. */
    setExecutableCapabilities(execPath: string, capabilities: string[], modeEffective?: boolean, modePermitted?: boolean, modeInherited?: boolean): Promise<void>;
    /** Extend an object (which might not belong to this adapter) and create it if it might not exist */
    extendForeignObjectAsync<T extends string>(id: T, objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options?: ioBroker.ExtendObjectOptions): ioBroker.SetObjectPromise;
    /** Reads an object from the object db */
    getObjectAsync(id: string, options?: unknown): ioBroker.GetObjectPromise;
    /**
     * Query a predefined object view (similar to SQL stored procedures) and return the results
     * For a detailed description refer to https://github.com/ioBroker/ioBroker/wiki/Adapter-Development-Documentation#object-fields
     * or http://guide.couchdb.org/editions/1/en/views.html
     */
    getObjectViewAsync<Design extends string = string, Search extends string = string>(design: Design, search: Search, params: ioBroker.GetObjectViewParams | null | undefined, options?: unknown): ioBroker.GetObjectViewPromise<ioBroker.InferGetObjectViewItemType<Design, Search>>;
    /** Returns a list of objects with id between params.startkey and params.endkey */
    getObjectListAsync(params: ioBroker.GetObjectListParams | null, options?: {
        sorted?: boolean;
    } | Record<string, any>): ioBroker.GetObjectListPromise;
    /** Returns the enum tree, filtered by the optional enum name */
    getEnumAsync(name: string, options?: unknown): Promise<{
        result: Record<string, any>;
        requestEnum: string;
    }>;
    /** Returns the enum tree, filtered by the optional enum name */
    getEnumsAsync(enumList?: ioBroker.EnumList, options?: unknown): ioBroker.GetEnumsPromise;
    /** Deletes an object from the object db */
    delObjectAsync(id: string, options?: ioBroker.DelObjectOptions): Promise<void>;
    /** Deletes an object (which might not belong to this adapter) from the object db */
    delForeignObjectAsync(id: string, options?: ioBroker.DelObjectOptions): Promise<void>;
    /** Subscribe to changes of objects in this instance */
    subscribeObjectsAsync(pattern: string, options?: unknown): Promise<void>;
    /** Unsubscribe from changes of objects in this instance */
    unsubscribeObjectsAsync(pattern: string, options?: unknown): Promise<void>;
    /** Read a value from the states DB. */
    getStateAsync(id: string, options?: unknown): ioBroker.GetStatePromise;
    /** Subscribe to changes of objects (which might not belong to this adapter) */
    subscribeForeignObjectsAsync(pattern: string | string[], options?: unknown): Promise<void>;
    /** Unsubscribe from changes of objects (which might not belong to this adapter) */
    unsubscribeForeignObjectsAsync(pattern: string | string[], options?: unknown): Promise<void>;
    /** Creates an object in the object db. Existing objects are not overwritten. */
    setObjectNotExistsAsync(id: string, obj: ioBroker.SettableObject, options?: unknown): ioBroker.SetObjectPromise;
    /** Creates an object (which might not belong to this adapter) in the object db. Existing objects are not overwritten. */
    setForeignObjectNotExistsAsync<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options?: unknown): ioBroker.SetObjectPromise;
    /** deletes a device, its channels and states */
    deleteDeviceAsync(deviceName: string, options?: unknown): Promise<void>;
    addChannelToEnumAsync(enumName: string, addTo: string, parentDevice: string, channelName: string, options?: unknown): Promise<void>;
    deleteChannelFromEnumAsync(enumName: string, parentDevice: string, channelName: string, options?: unknown): Promise<void>;
    /** Returns a list of all devices in this adapter instance */
    getDevicesAsync(options?: unknown): Promise<ioBroker.DeviceObject[]>;
    addStateToEnumAsync(enumName: string, addTo: string, parentDevice: string, parentChannel: string, stateName: string, options?: unknown): Promise<void>;
    deleteStateFromEnumAsync(enumName: string, parentDevice: string, parentChannel: string, stateName: string, options?: unknown): Promise<void>;
    /** Changes access rights of all files in the adapter directory */
    chmodFileAsync(adapter: string | null, path: string, options: {
        mode: number | string;
    } | Record<string, any>): Promise<{
        entries: ioBroker.ChownFileResult[];
        id: string;
    }>;
    chownFileAsync(...args: any[]): Promise<any>;
    /** reads the content of directory from DB for given adapter and path */
    readDirAsync(adapterName: string | null, path: string, options?: unknown): ioBroker.ReadDirPromise;
    /** Deletes a given file */
    unlinkAsync(adapterName: string | null, path: string, options?: unknown): Promise<void>;
    /** Deletes a given file */
    delFileAsync(adapterName: string | null, path: string, options?: unknown): Promise<void>;
    renameAsync(adapterName: string | null, oldName: string, newName: string, options?: unknown): Promise<void>;
    mkdirAsync(adapterName: string | null, path: string, options?: unknown): Promise<void>;
    /** reads the content of directory from DB for given adapter and path */
    readFileAsync(adapterName: string | null, path: string, options?: unknown): ioBroker.ReadFilePromise;
    writeFileAsync(adapterName: string | null, path: string, data: Buffer | string, options?: unknown): Promise<void>;
    /** Checks if a file exists in the DB */
    fileExistsAsync(adapterName: string | null, path: string, options?: unknown): Promise<boolean>;
    /** Read historian data for states of any instance or system state. */
    getHistoryAsync(id: string, options?: ioBroker.GetHistoryOptions): Promise<{
        result?: ioBroker.GetHistoryResult;
        step?: number;
        sessionId?: number;
    }>;
    /** Deletes a state from the states DB, but not the associated object. Consider using deleteState instead */
    delStateAsync(id: string, options?: unknown): Promise<void>;
    /** Deletes a state from the states DB, but not the associated object */
    delForeignStateAsync(id: string, options?: unknown): Promise<void>;
    /** Read all states of this adapter that match the given pattern */
    getStatesAsync(pattern: string, options?: unknown): ioBroker.GetStatesPromise;
    /** Read all states (which might not belong to this adapter) which match the given pattern */
    getForeignStatesAsync(pattern: Pattern, options?: unknown): ioBroker.GetStatesPromise;
    /** Subscribe to changes of states (which might not belong to this adapter) */
    subscribeForeignStatesAsync(pattern: string | string[], options?: unknown): Promise<void>;
    /** Subscribe from changes of states (which might not belong to this adapter) */
    unsubscribeForeignStatesAsync(pattern: string | string[], options?: unknown): Promise<void>;
    /** Subscribe to changes of states in this instance */
    subscribeStatesAsync(pattern: Pattern, options?: unknown): Promise<void>;
    /** Subscribe from changes of states in this instance */
    unsubscribeStatesAsync(pattern: Pattern, options?: unknown): Promise<void>;
    /**
     * Helper function that looks for the first free TCP port starting with the given one.
     */
    getPortAsync(port: number): Promise<number>;
    /** Read a value (which might not belong to this adapter) from the state's DB. */
    getForeignStateAsync(id: string, options?: unknown): ioBroker.GetStatePromise;
    /** Validates username and password */
    checkPasswordAsync(user: string, password: string, options?: unknown): Promise<[isPasswordCorrect: boolean, user: `system.user.${string}`]>;
    /** Sets a new password for the given user */
    setPasswordAsync(user: string, password: string, options?: unknown): Promise<void>;
    /** <INTERNAL> Checks if a user exists and is in the given group. */
    checkGroupAsync(user: string, group: string, options?: unknown): Promise<boolean>;
    /** <INTERNAL> Determines the users permissions */
    calculatePermissionsAsync(user: string, commandsPermissions: CommandsPermissions, options?: unknown): Promise<ioBroker.PermissionSet>;
    /**
     * Creates or overwrites an object in the object db
     *
     * @deprecated use `adapter.setObject` without a callback instead
     */
    setObjectAsync(id: string, obj: ioBroker.SettableObject, options?: unknown): ioBroker.SetObjectPromise;
    /**
     * Creates or overwrites an object (which might not belong to this adapter) in the object db
     *
     * @deprecated use `adapter.setForeignObject` without a callback instead
     */
    setForeignObjectAsync<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options?: unknown): ioBroker.SetObjectPromise;
    getCertificatesAsync(publicName?: string, privateName?: string, chainedName?: string): Promise<GetCertificatesPromiseReturnType>;
    /** Get all states, channels, devices and folders of this adapter */
    getAdapterObjectsAsync(): Promise<Record<string, ioBroker.AdapterScopedObject>>;
    /** Reads an object (which might not belong to this adapter) from the object db*/
    getForeignObjectAsync<T extends string>(id: T, options?: unknown): ioBroker.GetObjectPromise<T>;
    /**
     * Writes a value (which might not belong to this adapter) into the states DB only if it has changed.
     */
    setForeignStateChangedAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack?: boolean): ioBroker.SetStateChangedPromise;
    setForeignStateChangedAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options?: unknown): ioBroker.SetStateChangedPromise;
    setForeignStateChangedAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown): ioBroker.SetStateChangedPromise;
    /**
     * Writes a value into the states DB only if it has changed.
     */
    setStateChangedAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack?: boolean): ioBroker.SetStateChangedPromise;
    setStateChangedAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options?: unknown): ioBroker.SetStateChangedPromise;
    setStateChangedAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown): ioBroker.SetStateChangedPromise;
    /**
     * Sends a message to a specific host or all hosts.
     */
    sendToHostAsync(hostName: string, message: ioBroker.MessagePayload): Promise<ioBroker.Message | undefined>;
    sendToHostAsync(hostName: string, command: string, message: ioBroker.MessagePayload): Promise<ioBroker.Message | undefined>;
    /**
     * Sends a message to a specific instance or all instances of some specific adapter.
     */
    sendToAsync(instanceName: string, message: ioBroker.MessagePayload): Promise<ioBroker.Message | undefined>;
    sendToAsync(instanceName: string, command: string, message: ioBroker.MessagePayload, options?: SendToOptions): Promise<ioBroker.Message | undefined>;
    /**
     * Deletes a given file
     */
    delFile(adapterName: string | null, path: string, callback: ioBroker.ErrnoCallback): void;
    delFile(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ErrnoCallback): void;
    /**
     * Writes a value into the states DB.
     *
     * @deprecated use `adapter.setState` without callback instead
     */
    setStateAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack?: boolean): ioBroker.SetStatePromise;
    /** @deprecated use `adapter.setState` without callback instead */
    setStateAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options?: unknown): ioBroker.SetStatePromise;
    /** @deprecated use `adapter.setState` without callback instead */
    setStateAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown): ioBroker.SetStatePromise;
    /**
     * Writes a value (which might not belong to this adapter) into the states DB.
     */
    setForeignStateAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack?: boolean): ioBroker.SetStatePromise;
    setForeignStateAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options?: unknown): ioBroker.SetStatePromise;
    setForeignStateAsync(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown): ioBroker.SetStatePromise;
    /**
     * Get foreign objects by pattern, by specific type and resolve their enums.
     */
    getForeignObjectsAsync<T extends ioBroker.ObjectType>(pattern: Pattern, type: T, enums?: ioBroker.EnumList | null, options?: unknown): ioBroker.GetObjectsPromiseTyped<T>;
    getForeignObjectsAsync<T extends ioBroker.ObjectType>(pattern: Pattern, type: T, options?: unknown): ioBroker.GetObjectsPromiseTyped<T>;
    getForeignObjectsAsync(pattern: Pattern, options?: unknown): ioBroker.GetObjectsPromise;
    /**
     * creates an object with type device
     *
     * @deprecated use `extendObject` instead
     */
    createDeviceAsync(deviceName: string, common?: Partial<ioBroker.DeviceCommon>): ioBroker.SetObjectPromise;
    /** @deprecated use `extendObject` instead */
    createDeviceAsync(deviceName: string, common: Partial<ioBroker.DeviceCommon>, native?: Record<string, any>): ioBroker.SetObjectPromise;
    /** @deprecated use `extendObject` instead */
    createDeviceAsync(deviceName: string, common: Partial<ioBroker.DeviceCommon>, native: Record<string, any>, options?: unknown): ioBroker.SetObjectPromise;
    /**
     * Creates an object with a type channel. It must be located under a device
     *
     * @deprecated use `extendObject` instead
     */
    createChannelAsync(parentDevice: string, channelName: string, roleOrCommon?: string | Partial<ioBroker.ChannelCommon>): ioBroker.SetObjectPromise;
    /** @deprecated use `extendObject` instead */
    createChannelAsync(parentDevice: string, channelName: string, roleOrCommon: string | Partial<ioBroker.ChannelCommon>, native?: Record<string, any>): ioBroker.SetObjectPromise;
    /** @deprecated use `extendObject` instead */
    createChannelAsync(parentDevice: string, channelName: string, roleOrCommon: string | Partial<ioBroker.ChannelCommon>, native: Record<string, any>, options?: unknown): ioBroker.SetObjectPromise;
    /**
     * Creates a state and the corresponding object. It must be located in a channel under a device
     *
     * @deprecated use `extendObject` instead
     */
    createStateAsync(parentDevice: string, parentChannel: string, stateName: string, roleOrCommon?: string | Partial<ioBroker.StateCommon>): ioBroker.SetObjectPromise;
    /** @deprecated use `extendObject` instead */
    createStateAsync(parentDevice: string, parentChannel: string, stateName: string, roleOrCommon: string | Partial<ioBroker.StateCommon>, native?: Record<string, any>): ioBroker.SetObjectPromise;
    /** @deprecated use `extendObject` instead */
    createStateAsync(parentDevice: string, parentChannel: string, stateName: string, roleOrCommon: string | Partial<ioBroker.StateCommon>, native: Record<string, any>, options?: unknown): ioBroker.SetObjectPromise;
    /**
     * Deletes a channel and its states. It must have been created with createChannel
     *
     * @deprecated use `this.delObject` instead
     */
    deleteChannelAsync(channelName: string, options?: unknown): Promise<void>;
    /** @deprecated use `this.delObject` instead */
    deleteChannelAsync(parentDevice: string, channelName: string, options?: unknown): Promise<void>;
    /**
     * Deletes a state. It must have been created with createState
     *
     * @deprecated use `this.delObject` instead
     */
    deleteStateAsync(stateName: string, options?: unknown): Promise<void>;
    /** @deprecated use `this.delObject` instead */
    deleteStateAsync(parentChannel: string, stateName: string, options?: unknown): Promise<void>;
    /** @deprecated use `this.delObject` instead */
    deleteStateAsync(parentDevice: string, parentChannel: string, stateName: string, options?: unknown): Promise<void>;
    /**
     * Returns a list of all channels in this adapter instance @param parentDevice (optional) Name
     * of the parent device to filter the channels by @param options (optional) Some internal options.
     */
    getChannelsOfAsync(): Promise<ioBroker.ChannelObject[]>;
    getChannelsOfAsync(parentDevice: string, options?: unknown): Promise<ioBroker.ChannelObject[]>;
    /**
     * Returns a list of all channels in this adapter instance
     */
    getChannels(callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;
    getChannels(parentDevice: string, callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;
    getChannels(parentDevice: string, options: unknown, callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;
    /**
     * Returns a list of all channels in this adapter instance @param parentDevice (optional)
     * Name of the parent device to filter the channels by @param options (optional) Some internal options.
     */
    getChannelsAsync(): Promise<ioBroker.ChannelObject[]>;
    getChannelsAsync(parentDevice: string, options?: unknown): Promise<ioBroker.ChannelObject[]>;
    /**
     * Returns a list of all states in this adapter instance @param parentDevice (optional)
     * Name of the parent device to filter the channels by @param parentChannel (optional)
     * Name of the parent channel to filter the channels by @param options (optional) Some internal options.
     */
    getStatesOfAsync(): Promise<ioBroker.StateObject[]>;
    getStatesOfAsync(parentDevice: string, parentChannel?: string): Promise<ioBroker.StateObject[]>;
    getStatesOfAsync(parentDevice: string, parentChannel: string, options?: unknown): Promise<ioBroker.StateObject[]>;
}

/**
 * Adapter class
 *
 * How the initialization happens:
 *  _initObjects => _initStates => _prepareInitAdapter => _initAdapter => _initLogging => _createInstancesObjects => ready
 *
 */
export declare class AdapterClass extends EventEmitter {
    #private;
    /** Cache of all deprecations which have already been transmitted */
    private reportedDeprecations;
    /** States DB constructor */
    private States?;
    /** Objects DB constructor */
    private Objects?;
    /** Contents of iobroker.json */
    private readonly _config;
    private readonly _options;
    private readonly startedInCompactMode;
    /** List of instances which want our logs */
    private readonly logList;
    private readonly aliases;
    private readonly aliasPatterns;
    private enums;
    private eventLoopLags;
    private overwriteLogLevel;
    adapterReady: boolean;
    /** Callbacks from sendTo */
    private readonly messageCallbacks;
    /**
     * Contains a live cache of the adapter's states.
     * NOTE: This is only defined if the adapter was initialized with the option states: true.
     */
    oStates?: Record<string, ioBroker.State | undefined>;
    /**
     * Contains a live cache of the adapter's objects.
     * NOTE: This is only defined if the adapter was initialized with the option objects: true.
     */
    oObjects?: Record<string, ioBroker.Object | undefined>;
    private _stopInProgress;
    private _callbackId;
    private _firstConnection;
    private readonly _timers;
    private readonly _intervals;
    private readonly _delays;
    /** For ease of use the log property is always defined, however it is only available after `ready` has been called. */
    log: Log;
    performStrictObjectChecks: boolean;
    private readonly _logger;
    private _restartScheduleJob;
    private _schedule?;
    private namespaceLog;
    namespace: `${string}.${number}`;
    name: string;
    private _systemSecret?;
    /** Whether the adapter has already terminated */
    private terminated;
    /** The cache of usernames */
    private usernames;
    /** A RegExp to test for forbidden chars in object IDs */
    readonly FORBIDDEN_CHARS: RegExp;
    private inputCount;
    private outputCount;
    /** The cache of users */
    private users;
    /** The cache of user groups */
    private groups;
    /** An array of instances, that support auto subscribe */
    private autoSubscribe;
    private defaultHistory;
    private pluginHandler?;
    private _reportInterval?;
    private getPortRunning;
    private readonly _namespaceRegExp;
    instance?: number;
    private _utils;
    /** contents of io-package.json */
    adapterConfig?: AdapterOptions | ioBroker.InstanceObject | null;
    connected?: boolean;
    adapterDir: string;
    /** contents of package.json */
    pack?: Record<string, any>;
    /** contents of io-package.json */
    ioPack: ioBroker.InstanceObject;
    private _initializeTimeout?;
    private inited?;
    /** contents of iobroker.json if required via AdapterOptions */
    systemConfig?: InternalAdapterJsonConfig;
    /** the configured date format of system.config, only available if requested via AdapterOptions `useFormatDate` */
    dateFormat?: any;
    /** if float comma instead of dot is used, only available if requested via AdapterOptions `useFormatDate` */
    isFloatComma?: boolean;
    /** configured language of system.config, only available if requested via AdapterOptions `useFormatDate` */
    language?: ioBroker.Languages;
    /** longitude configured in system.config, only available if requested via AdapterOptions `useFormatDate`*/
    longitude?: number;
    /** latitude configured in system.config, only available if requested via AdapterOptions `useFormatDate`*/
    latitude?: number;
    private _defaultObjs?;
    private _aliasObjectsSubscribed?;
    config: ioBroker.AdapterConfig;
    host?: string;
    common?: ioBroker.InstanceCommon;
    private mboxSubscribed?;
    /** Stop the adapter */
    stop?: (params?: StopParameters) => Promise<void>;
    version?: string;
    /** Stop the adapter only defined in compact, not for external usage */
    protected kill?: () => Promise<void>;
    processLog?: (msg: ioBroker.LogMessage) => void;
    /**
     * Start or stop subscribing to log messages
     * The method is only available if logTransporter is active via io-pack or adapter options
     * Note, that stopping will stop after 10 seconds, not immediately
     *
     * @param isActive - if log subscription should be activated or deactivated
     * @param options - options passed to setState e.g. user permissions
     */
    requireLog?: (isActive: boolean, options?: Partial<GetUserGroupsOptions>) => Promise<void> | void;
    private logOffTimer?;
    private logRequired?;
    private patterns?;
    private statesConnectedTime?;
    /** Constants for frequent use in adapters */
    readonly constants: {
        readonly STATE_QUALITY: typeof STATE_QUALITY;
    };
    /** Features supported by the running instance */
    private readonly SUPPORTED_FEATURES;
    /** Controller for messaging related functionality */
    private readonly uiMessagingController;
    constructor(options: AdapterOptions | string);
    /**
     * Get the adapter scoped package identifier of a node module
     *
     * @param moduleName name of the node module
     */
    getAdapterScopedPackageIdentifier(moduleName: string): string;
    installNodeModule(moduleName: string, options: InstallNodeModuleOptions): Promise<CommandResult>;
    private _installNodeModule;
    /**
     * List all additional installed node modules from this adapter
     */
    listInstalledNodeModules(): Promise<string[]>;
    uninstallNodeModule(moduleName: string): Promise<CommandResult>;
    importNodeModule(moduleName: string): Promise<unknown>;
    decrypt(secretVal: string, value?: string): string;
    decrypt(value: string): string;
    encrypt(secretVal: string, value?: string): string;
    encrypt(value: string): string;
    getSession(id: string, callback: ioBroker.GetSessionCallback): MaybePromise;
    private _getSession;
    setSession(id: string, ttl: number, data: Record<string, any>, callback?: ioBroker.ErrorCallback): MaybePromise;
    private _setSession;
    destroySession(id: string, callback?: ioBroker.ErrorCallback): MaybePromise;
    private _destroySession;
    private _getObjectsByArray;
    terminate(exitCode?: number): never;
    terminate(reason?: string, exitCode?: number): never;
    getPort(port: number, host?: string, callback?: (port: number) => void): void;
    getPort(port: number, callback?: (port: number) => void): void;
    private _getPort;
    supportsFeature(featureName: SupportedFeature): boolean;
    checkPassword(user: string, pw: string, options: Record<string, any>, callback: CheckPasswordCallback): Promise<void>;
    checkPassword(user: string, pw: string, callback: CheckPasswordCallback): Promise<void>;
    private _checkPassword;
    /**
     * This method updates the cached values in `this.usernames`
     */
    private _updateUsernameCache;
    getUserID(username: string): Promise<string | undefined>;
    private _getUserID;
    setPassword(user: string, pw: string, options: Record<string, any>, callback?: ioBroker.ErrorCallback): Promise<void>;
    setPassword(user: string, pw: string, callback?: ioBroker.ErrorCallback): Promise<void>;
    private _setPassword;
    checkGroup(user: string, group: string, options: Record<string, any>, callback?: CheckGroupCallback): Promise<void>;
    checkGroup(user: string, group: string, callback?: CheckGroupCallback): Promise<void>;
    private _checkGroup;
    calculatePermissions(user: string, commandsPermissions: CommandsPermissions, options?: Record<string, any>, callback?: CalculatePermissionsCallback): Promise<void | ioBroker.PermissionSet>;
    calculatePermissions(user: string, commandsPermissions: CommandsPermissions, callback?: CalculatePermissionsCallback): Promise<void | ioBroker.PermissionSet>;
    private _calculatePermissions;
    /**
     * Stop an instance gracefully
     *
     * @param options information about the stoppage
     */
    private _stop;
    /**
     * Reads the file certificate from a given path and adds a file watcher to restart adapter on cert changes
     * if a cert is passed it is returned as it is
     *
     * @param cert cert or path to cert
     */
    private _readFileCertificate;
    getCertificates(publicName?: string, privateName?: string, chainedName?: string, callback?: GetCertificatesCallback): void;
    private _getCertificates;
    /**
     * Restarts an instance of the adapter.
     *
     */
    restart(): void;
    updateConfig(newConfig: Record<string, any>): ioBroker.SetObjectPromise;
    private _updateConfig;
    /**
     * Disables and stops the adapter instance.
     *
     */
    disable(): ioBroker.SetObjectPromise;
    getEncryptedConfig(attribute: string, callback?: GetEncryptedConfigCallback): Promise<string | string[] | void>;
    private _getEncryptedConfig;
    /**
     * Get the system secret, after retrieved once it will be read from the cache
     */
    private getSystemSecret;
    setTimeout<TCallback extends TimeoutCallback>(cb: TCallback, timeout: number, ...args: Parameters<TCallback>): ioBroker.Timeout | undefined;
    clearTimeout(timer: ioBroker.Timeout | undefined): void;
    delay(timeout: number): Promise<void>;
    setInterval<TCallback extends TimeoutCallback>(cb: TCallback, timeout: number, ...args: Parameters<TCallback>): ioBroker.Interval | undefined;
    clearInterval(interval: ioBroker.Interval | undefined): void;
    setObject(id: string, obj: ioBroker.SettableObject): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    setObject(id: string, obj: ioBroker.SettableObject, callback: ioBroker.SetObjectCallback): void;
    setObject(id: string, obj: ioBroker.SettableObject, options: unknown, callback: ioBroker.SetObjectCallback): void;
    setObject(id: string, obj: ioBroker.SettableObject, options: unknown): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    private _setObject;
    /**
     * Helper method for `set[Foreign]Object[NotExists]` that also sets the default value if one is configured
     *
     * @param id of the object
     * @param obj The object to set
     * @param options optional user context
     * @param callback optional callback
     */
    private _setObjectWithDefaultValue;
    getAdapterObjects(callback: (objects: Record<string, ioBroker.AdapterScopedObject>) => void): Promise<Record<string, ioBroker.AdapterScopedObject> | void>;
    private _getAdapterObjects;
    extendObject(id: string, objPart: ioBroker.PartialObject): ioBroker.SetObjectPromise;
    extendObject(id: string, objPart: ioBroker.PartialObject, callback?: ioBroker.SetObjectCallback): void;
    extendObject(id: string, objPart: ioBroker.PartialObject, options: ioBroker.ExtendObjectOptions): ioBroker.SetObjectPromise;
    extendObject(id: string, objPart: ioBroker.PartialObject, options: ioBroker.ExtendObjectOptions, callback?: ioBroker.SetObjectCallback): void;
    private _extendObject;
    setForeignObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    setForeignObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, callback: ioBroker.SetObjectCallback): void;
    setForeignObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options: unknown): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    setForeignObject<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options: unknown, callback?: ioBroker.SetObjectCallback): void | Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    private _setForeignObject;
    extendForeignObject<T extends string>(id: T, objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    extendForeignObject<T extends string>(id: T, objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, callback: ioBroker.SetObjectCallback): void;
    extendForeignObject<T extends string>(id: T, objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options: ioBroker.ExtendObjectOptions, callback: ioBroker.SetObjectCallback): void;
    extendForeignObject<T extends string>(id: T, objPart: ioBroker.PartialObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options: ioBroker.ExtendObjectOptions): Promise<ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>>;
    private _extendForeignObjectAsync;
    objectExists(id: string, options?: Record<string, any> | null): Promise<boolean | void>;
    foreignObjectExists(id: string, options?: Record<string, any> | null): Promise<boolean | void>;
    getObject(id: string, callback: ioBroker.GetObjectCallback): void;
    getObject(id: string, options: unknown, callback: ioBroker.GetObjectCallback): void;
    getObjectView<Design extends string = string, Search extends string = string>(design: Design, search: Search, params: ioBroker.GetObjectViewParams | null | undefined, callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>): void;
    getObjectView<Design extends string = string, Search extends string = string>(design: Design, search: Search, params: ioBroker.GetObjectViewParams | null | undefined, options: unknown, callback: ioBroker.GetObjectViewCallback<ioBroker.InferGetObjectViewItemType<Design, Search>>): void;
    private _getObjectView;
    getObjectList(params: ioBroker.GetObjectListParams | null, callback: ioBroker.GetObjectListCallback<ioBroker.Object>): void;
    getObjectList(params: ioBroker.GetObjectListParams | null, options: {
        sorted?: boolean;
    } | Record<string, any>, callback: ioBroker.GetObjectListCallback<ioBroker.Object>): void;
    getEnum(callback: ioBroker.GetEnumCallback): void;
    getEnum(name: string, callback: ioBroker.GetEnumCallback): void;
    getEnum(name: string, options: unknown, callback: ioBroker.GetEnumCallback): void;
    private _getEnum;
    getEnums(callback: ioBroker.GetEnumsCallback): void;
    getEnums(enumList: ioBroker.EnumList, callback: ioBroker.GetEnumsCallback): void;
    getEnums(enumList: ioBroker.EnumList, options: unknown, callback: ioBroker.GetEnumsCallback): void;
    private _getEnums;
    getForeignObjects(patter: Pattern): Promise<ioBroker.NonNullCallbackReturnTypeOf<ioBroker.GetObjectsCallback>>;
    getForeignObjects(pattern: Pattern, callback: ioBroker.GetObjectsCallback): void;
    getForeignObjects(pattern: Pattern, options: unknown, callback: ioBroker.GetObjectsCallback): void;
    getForeignObjects<T extends ioBroker.ObjectType>(pattern: Pattern, type: T, callback: ioBroker.GetObjectsCallbackTyped<T>): void;
    getForeignObjects<T extends ioBroker.ObjectType>(pattern: Pattern, type: T, enums: ioBroker.EnumList, callback: ioBroker.GetObjectsCallbackTyped<T>): void;
    getForeignObjects<T extends ioBroker.ObjectType>(pattern: Pattern, type: T, options: unknown, callback: ioBroker.GetObjectsCallbackTyped<T>): void;
    getForeignObjects<T extends ioBroker.ObjectType>(pattern: Pattern, type: T, enums: ioBroker.EnumList | null, options: unknown, callback: ioBroker.GetObjectsCallbackTyped<T>): void;
    private _getForeignObjects;
    findForeignObject(idOrName: string, type: ioBroker.CommonType | null, callback: ioBroker.FindObjectCallback): void;
    findForeignObject(idOrName: string, type: ioBroker.CommonType | null, options: {
        user?: `system.user.${string}`;
        language?: ioBroker.Languages;
        /** This can be set to true to disable permission checks if they were already checked otherwise. Use it with caution! */
        checked?: boolean;
        /** Search only within the states, that belongs to this user */
        limitToOwnerRights?: boolean;
    }, callback: ioBroker.FindObjectCallback): void;
    /**
     * Find an object by the exact name or ID.
     *
     * @param id exactly object ID (without a namespace)
     * @param type optional `common.type` of the state: 'number', 'string', 'boolean', 'file', ...
     * @param options optional user context with language
     * @param options.user current user
     * @param options.language language in which the search must be done for multi-language names
     * @result if the object was found by ID it will return id and may be the multi-language name it exists. If the object was found by name it will return id and the multi-language name. If the object was not found, it will return only name that was searched for.
     */
    findForeignObjectAsync(id: string, type: ioBroker.CommonType | null, options?: {
        user?: `system.user.${string}`;
        language?: ioBroker.Languages;
    }): Promise<{
        id?: string;
        name: ioBroker.StringOrTranslated;
    }>;
    getForeignObject<T extends string>(id: T, callback: ioBroker.GetObjectCallback<T>): void | Promise<void | ioBroker.ObjectIdToObjectType<T> | null>;
    getForeignObject<T extends string>(id: T, options: unknown, callback: ioBroker.GetObjectCallback<T>): void | Promise<void | ioBroker.ObjectIdToObjectType<T> | null>;
    private _getForeignObject;
    delObject(id: string, callback?: ioBroker.ErrorCallback): void;
    delObject(id: string, options?: ioBroker.DelObjectOptions | null, callback?: ioBroker.ErrorCallback): void;
    private _deleteObjects;
    delForeignObject(id: string, callback?: ioBroker.ErrorCallback): void;
    delForeignObject(id: string, options: ioBroker.DelObjectOptions, callback?: ioBroker.ErrorCallback): void;
    private _delForeignObject;
    subscribeObjects(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;
    subscribeObjects(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;
    unsubscribeObjects(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;
    unsubscribeObjects(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;
    subscribeForeignObjects(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;
    subscribeForeignObjects(pattern: string | string[], options: unknown, callback?: ioBroker.ErrorCallback): void;
    unsubscribeForeignObjects(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;
    unsubscribeForeignObjects(pattern: string | string[], options: unknown, callback?: ioBroker.ErrorCallback): void;
    subscribeForeignFiles(id: string, pattern: string | string[], options?: unknown): Promise<void>;
    unsubscribeForeignFiles(id: string, pattern: string | string[], options?: unknown): Promise<void>;
    setObjectNotExists(id: string, obj: ioBroker.SettableObject, callback?: ioBroker.SetObjectCallback): Promise<void | ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> | void;
    setObjectNotExists(id: string, obj: ioBroker.SettableObject, options: unknown, callback?: ioBroker.SetObjectCallback): Promise<void | ioBroker.CallbackReturnTypeOf<ioBroker.SetObjectCallback>> | void;
    private _setObjectNotExists;
    setForeignObjectNotExists<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, callback?: ioBroker.SetObjectCallback): void;
    setForeignObjectNotExists<T extends string>(id: T, obj: ioBroker.SettableObject<ioBroker.ObjectIdToObjectType<T, 'write'>>, options: unknown, callback?: ioBroker.SetObjectCallback): void;
    private _setForeignObjectNotExists;
    private _DCS2ID;
    /** @deprecated use `this.extendObject` instead */
    createDevice(deviceName: string, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createDevice(deviceName: string, common: Partial<ioBroker.DeviceCommon>, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createDevice(deviceName: string, common: Partial<ioBroker.DeviceCommon>, native: Record<string, any>, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createDevice(deviceName: string, common: Partial<ioBroker.DeviceCommon>, native: Record<string, any>, options: unknown, callback?: ioBroker.SetObjectCallback): void;
    private _createDevice;
    /** @deprecated use `this.extendObject` instead */
    createChannel(parentDevice: string, channelName: string, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createChannel(parentDevice: string, channelName: string, roleOrCommon: string | Partial<ioBroker.ChannelCommon>, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createChannel(parentDevice: string, channelName: string, roleOrCommon: string | Partial<ioBroker.ChannelCommon>, native: Record<string, any>, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createChannel(parentDevice: string, channelName: string, roleOrCommon: string | Partial<ioBroker.ChannelCommon>, native: Record<string, any>, options: unknown, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createState(parentDevice: string, parentChannel: string, stateName: string, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createState(parentDevice: string, parentChannel: string, stateName: string, roleOrCommon: string | Partial<ioBroker.StateCommon>, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createState(parentDevice: string, parentChannel: string, stateName: string, roleOrCommon: string | Partial<ioBroker.StateCommon>, native: Record<string, any>, callback?: ioBroker.SetObjectCallback): void;
    /** @deprecated use `this.extendObject` instead */
    createState(parentDevice: string, parentChannel: string, stateName: string, roleOrCommon: string | Partial<ioBroker.StateCommon>, native: Record<string, any>, options: unknown, callback?: ioBroker.SetObjectCallback): void;
    private _createState;
    /** @deprecated use `this.delObject` instead */
    deleteDevice(deviceName: string, callback?: ioBroker.ErrorCallback): void;
    /** @deprecated use `this.delObject` instead */
    deleteDevice(deviceName: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _deleteDevice;
    addChannelToEnum(enumName: string, addTo: string, parentDevice: string, channelName: string, callback?: ioBroker.ErrorCallback): void;
    addChannelToEnum(enumName: string, addTo: string, parentDevice: string, channelName: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _addChannelToEnum;
    deleteChannelFromEnum(enumName: string, parentDevice: string, channelName: string, callback?: ioBroker.ErrorCallback): void;
    deleteChannelFromEnum(enumName: string, parentDevice: string, channelName: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _deleteChannelFromEnum;
    /** @deprecated use `this.delObject` instead */
    deleteChannel(channelName: string, callback?: ioBroker.ErrorCallback): void;
    /** @deprecated use `this.delObject` instead */
    deleteChannel(channelName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;
    /** @deprecated use `this.delObject` instead */
    deleteChannel(parentDevice: string, channelName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;
    private _deleteChannel;
    /** @deprecated use `this.delObject` instead */
    deleteState(parentChannel: string, stateName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;
    /** @deprecated use `this.delObject` instead */
    deleteState(stateName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;
    /** @deprecated use `this.delObject` instead */
    deleteState(parentDevice: string | null, parentChannel: string | null, stateName: string, options?: unknown, callback?: ioBroker.ErrorCallback): void;
    private _deleteState;
    getDevices(callback: ioBroker.GetObjectsCallback3<ioBroker.DeviceObject>): void;
    getDevices(options: unknown, callback: ioBroker.GetObjectsCallback3<ioBroker.DeviceObject>): void;
    private _getDevices;
    getChannelsOf(callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;
    getChannelsOf(parentDevice: string, callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;
    getChannelsOf(parentDevice: string, options: unknown, callback: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>): void;
    private _getChannelsOf;
    getStatesOf(callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>): void;
    getStatesOf(parentDevice: string, callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>): void;
    getStatesOf(parentDevice: string | null | undefined, parentChannel: string | null | undefined, callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>): void;
    getStatesOf(parentDevice: string | null | undefined, parentChannel: string | null | undefined, options: unknown, callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>): void;
    private _getStatesOf;
    addStateToEnum(enumName: string, addTo: string, parentDevice: string, parentChannel: string, stateName: string, callback?: ioBroker.ErrorCallback): void;
    addStateToEnum(enumName: string, addTo: string, parentDevice: string, parentChannel: string, stateName: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _addStateToEnum;
    deleteStateFromEnum(enumName: string, parentDevice: string, parentChannel: string, stateName: string, callback?: ioBroker.ErrorCallback): void;
    deleteStateFromEnum(enumName: string, parentDevice: string, parentChannel: string, stateName: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _deleteStateFromEnum;
    chmodFile(adapter: string | null, path: string, options: {
        mode: number | string;
    } | Record<string, any>, callback: ioBroker.ChownFileCallback): void;
    chmodFile(adapter: string | null, path: string, callback: ioBroker.ChownFileCallback): void;
    chownFile(_adapter: string, path: string, options: unknown, callback: (err?: Error | null, processedFiles?: any) => void): void;
    chownFile(_adapter: string, path: string, callback: (err?: Error | null, processedFiles?: any) => void): void;
    readDir(adapterName: string | null, path: string, callback: ioBroker.ReadDirCallback): void;
    readDir(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ReadDirCallback): void;
    unlink(adapterName: string | null, path: string, callback: ioBroker.ErrnoCallback): void;
    unlink(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ErrnoCallback): void;
    rename(adapterName: string | null, oldName: string, newName: string, callback: ioBroker.ErrnoCallback): void;
    rename(adapterName: string | null, oldName: string, newName: string, options: unknown, callback: ioBroker.ErrnoCallback): void;
    mkdir(adapterName: string | null, path: string, callback: ioBroker.ErrnoCallback): void;
    mkdir(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ErrnoCallback): void;
    readFile(adapterName: string | null, path: string, callback: ioBroker.ReadFileCallback): void;
    readFile(adapterName: string | null, path: string, options: unknown, callback: ioBroker.ReadFileCallback): void;
    writeFile(adapterName: string | null, path: string, data: Buffer | string, callback: ioBroker.ErrnoCallback): void;
    writeFile(adapterName: string | null, path: string, data: Buffer | string, options: unknown, callback: ioBroker.ErrnoCallback): void;
    fileExists(adapterName: string | null, path: string): Promise<boolean>;
    fileExists(adapterName: string | null, path: string, callback?: ioBroker.GenericCallback<boolean>): void;
    fileExists(adapterName: string | null, path: string, options: unknown, callback: ioBroker.GenericCallback<boolean>): void;
    formatValue(value: number | string, format?: string): string;
    formatValue(value: number | string, decimals: number, format?: string): string;
    formatDate(dateObj: string | Date | number, format?: string): string;
    formatDate(dateObj: string | Date | number, isDuration: boolean | string, format?: string): string;
    private _formatDate;
    sendTo(instanceName: string, message: any, callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo): void;
    sendTo(instanceName: string, command: string, message: any, callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo, options?: SendToOptions): void;
    private _sendTo;
    sendToHost(hostName: string | null, message: any, callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo): void;
    sendToHost(hostName: string | null, command: string, message: any, callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo): void;
    private _sendToHost;
    sendToUI(options: SendToUserInterfaceClientOptions): Promise<void>;
    registerNotification<Scope extends keyof ioBroker.NotificationScopes>(scope: Scope, category: ioBroker.NotificationScopes[Scope] | null, message: string, options?: NotificationOptions): Promise<void>;
    setState<T extends ioBroker.SetStateCallback | undefined>(id: string | ioBroker.IdObject, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, callback?: T): T extends unknown ? ioBroker.SetStatePromise : void;
    setState<T extends ioBroker.SetStateCallback | undefined>(id: string | ioBroker.IdObject, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, callback?: T): T extends unknown ? ioBroker.SetStatePromise : void;
    setState<T extends ioBroker.SetStateCallback | undefined>(id: string | ioBroker.IdObject, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options?: Partial<GetUserGroupsOptions> | null, callback?: T): T extends unknown ? ioBroker.SetStatePromise : void;
    setState<T extends ioBroker.SetStateCallback | undefined>(id: string | ioBroker.IdObject, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options?: Partial<GetUserGroupsOptions> | null, callback?: T): T extends unknown ? ioBroker.SetStatePromise : void;
    private _setState;
    private _getUserGroups;
    private _checkState;
    private _checkStates;
    private _getGroups;
    private _setStateChangedHelper;
    setStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, callback?: ioBroker.SetStateChangedCallback): void;
    setStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, callback?: ioBroker.SetStateChangedCallback): void;
    setStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options: unknown, callback?: ioBroker.SetStateChangedCallback): void;
    setStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown, callback?: ioBroker.SetStateChangedCallback): void;
    private _setStateChanged;
    setForeignState(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, callback?: ioBroker.SetStateCallback): void;
    setForeignState(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, callback?: ioBroker.SetStateCallback): void;
    setForeignState(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options: unknown, callback?: ioBroker.SetStateCallback): void;
    setForeignState(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown, callback?: ioBroker.SetStateCallback): void;
    setForeignStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, callback?: ioBroker.SetStateChangedCallback): void;
    setForeignStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, callback?: ioBroker.SetStateChangedCallback): void;
    setForeignStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, options: unknown, callback?: ioBroker.SetStateChangedCallback): void;
    setForeignStateChanged(id: string, state: ioBroker.State | ioBroker.StateValue | ioBroker.SettableState, ack: boolean, options: unknown, callback?: ioBroker.SetStateChangedCallback): void;
    getState(id: string, callback: ioBroker.GetStateCallback): void;
    getState(id: string, options: unknown, callback: ioBroker.GetStateCallback): void;
    getForeignState(id: string, callback: ioBroker.GetStateCallback): ioBroker.GetStatePromise;
    getForeignState(id: string, options: unknown, callback: ioBroker.GetStateCallback): ioBroker.GetStatePromise;
    private _getForeignState;
    private _getDefaultHistory;
    getHistory(id: string, options: ioBroker.GetHistoryOptions, callback: ioBroker.GetHistoryCallback): void;
    getHistory(id: string, callback: ioBroker.GetHistoryCallback): void;
    private _getHistory;
    idToDCS(id: string): {
        device: string;
        channel: string;
        state: string;
    } | null;
    delState(id: string, callback?: ioBroker.ErrorCallback): void;
    delState(id: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _delState;
    delForeignState(id: string, callback?: ioBroker.ErrorCallback): void;
    delForeignState(id: string, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _delForeignState;
    getStates(pattern: Pattern, callback: ioBroker.GetStatesCallback): void;
    getStates(pattern: Pattern, options: unknown, callback: ioBroker.GetStatesCallback): void;
    private _processStatesSecondary;
    /**
     * Ensures, that object information is read, and the alias id is mapped to the source id if an alias is contained in the getStates call
     * The adaption of the actual values is then performed in _processStatesSecondary, to apply alias conversion methods
     *
     * @param keys all ids of the getStates call
     * @param targetObjs the target objects (e.g. alias objects or the actual objects)
     */
    private _processStates;
    getForeignStates(pattern: Pattern, callback: ioBroker.GetStatesCallback): void;
    getForeignStates(pattern: Pattern, options: unknown, callback: ioBroker.GetStatesCallback): void;
    private _getForeignStates;
    /**
     * Add subscription for given alias, if it is not a state it will be ignored
     *
     * @param aliasObj the alias object
     * @param pattern pattern to subscribe for
     */
    private _addAliasSubscribe;
    /**
     * Remove an alias subscribe
     *
     * @param sourceId id of the source object
     * @param aliasObjOrIdx the alias target or the index of the targets array
     */
    private _removeAliasSubscribe;
    subscribeForeignStates(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;
    subscribeForeignStates(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _subscribeForeignStates;
    unsubscribeForeignStates(pattern: string | string[], callback?: ioBroker.ErrorCallback): void;
    unsubscribeForeignStates(pattern: string | string[], options: unknown, callback?: ioBroker.ErrorCallback): void;
    private _unsubscribeForeignStates;
    subscribeStates(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;
    subscribeStates(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;
    unsubscribeStates(pattern: Pattern, callback?: ioBroker.ErrorCallback): void;
    unsubscribeStates(pattern: Pattern, options: unknown, callback?: ioBroker.ErrorCallback): void;
    getPluginInstance(name: string): ioBroker.Plugin | null;
    getPluginConfig(name: string): Record<string, any> | null;
    private _autoSubscribeOn;
    getSuitableLicenses(all?: boolean, adapterName?: string): Promise<any[]>;
    /**
     * Add given id to log redirect list
     *
     * @param isActive if id should be added or removed
     * @param id the id to add
     */
    private logRedirect;
    private _reportStatus;
    private _checkLogging;
    /**
     * Initialize the logging logic
     */
    private _initLogging;
    private _initStates;
    private _initObjects;
    /**
     * Called if states and objects successfully initialized
     */
    private _prepareInitAdapter;
    /**
     * Initialize the adapter
     *
     * @param adapterConfig the AdapterOptions or the InstanceObject, is null/undefined if it is an installation process
     */
    private _initAdapter;
    /**
     * Calls the ready handler, if it is an install run it calls the install handler instead
     */
    private _callReadyHandler;
    private _exceptionHandler;
    private _createInstancesObjects;
    private _extendObjects;
    /**
     * Replaces forbidden chars in an id if present
     * Additionally logs a warning
     *
     * @param id the id which will be replaced
     */
    private fixForbiddenCharsInId;
    /**
     * This method reports deprecations via Sentry (controller own instance) and can only be used internally
     *
     * @param options information about version to remove feature and the log message
     */
    private reportDeprecation;
    /**
     * Initialize the plugin handler for this adapter
     */
    private _initPluginHandler;
    /**
     * Initializes the adapter
     */
    private _init;
}

export declare interface AdapterOptions {
    subscribesChange?: (subs: Record<string, {
        regex: RegExp;
    }>) => void;
    /** If the adapter collects logs from all adapters (experts only). Default: false */
    logTransporter?: boolean;
    /** if true, the date format from system.config */
    useFormatDate?: boolean;
    /** if it is possible for other instances to retrieve states of this adapter automatically */
    subscribable?: boolean;
    /** compact group instance if running in compact mode */
    compactInstance?: number;
    /** if desired to have oStates. This is a list with all states values, and it will be updated automatically. */
    states?: boolean;
    /** if desired to have oObjects. This is a list with all states, channels and devices of this adapter, and it will be updated automatically.*/
    objects?: boolean;
    /** instance number of adapter */
    instance?: number;
    /** adapter directory name */
    dirname?: string;
    /** flag which defaults to true - if true, adapter warns if states are set without a corresponding existing object */
    strictObjectChecks?: boolean;
    /** If true runs in compact mode */
    compact?: boolean;
    /** configuration of the connection to controller */
    config?: AdapterOptionsConfig;
    /** name of the adapter. Must be exactly the same as directory name. */
    name: string;
    /** If true, the systemConfig (iobroker.json) will be available in this.systemConfig */
    systemConfig?: boolean;
    /** callback function (id, obj) that will be called if an object changed */
    objectChange?: ioBroker.ObjectChangeHandler;
    /** callback function (id, obj) that will be called if state changed */
    stateChange?: ioBroker.StateChangeHandler;
    /** callback function (id, file) that will be called if file changed */
    fileChange?: ioBroker.FileChangeHandler;
    /** callback function that will be called when a new UI client subscribes */
    uiClientSubscribe?: UserInterfaceClientSubscribeHandler;
    /** callback function that will be called when a new UI client unsubscribes */
    uiClientUnsubscribe?: UserInterfaceClientUnsubscribeHandler;
    /** callback to inform about a new message the adapter */
    message?: ioBroker.MessageHandler;
    /** callback to stop the adapter */
    unload?: ioBroker.UnloadHandler;
    /** called when adapter is ready */
    ready?: ioBroker.ReadyHandler;
    /** called when adapter is installed */
    install?: ioBroker.ReadyHandler;
    /** called on reconnection to DB */
    reconnect?: () => MaybePromise;
    /** Handler to handle uncaught exceptions, return true if no further handling required */
    error?: ioBroker.ErrorHandler;
}

export declare interface AdapterOptionsConfig {
    log: {
        level: ioBroker.LogLevel;
    };
}

export declare interface AliasDetails {
    source?: AliasDetailsSource;
    targets: AliasTargetEntry[];
}

export declare interface AliasDetailsSource {
    min?: number;
    max?: number;
    type?: ioBroker.CommonType;
    unit?: string;
}

export declare interface AliasTargetEntry {
    alias: ioBroker.StateCommon['alias'];
    id: string;
    pattern: string;
    type?: ioBroker.CommonType;
    max?: number;
    min?: number;
    unit?: string;
}

export declare type AllPropsUnknown<T> = {
    [K in keyof T]: unknown;
};

export declare type CalculatePermissionsCallback = (result: ioBroker.PermissionSet) => void;

declare type Callback = (...args: any[]) => void | Promise<void>;

export declare type CheckGroupCallback = (result: boolean) => void;

export declare type CheckPasswordCallback = (success: boolean, user: string) => void;

export declare type CheckStateCommand = 'getState' | 'setState' | 'delState';

export declare interface CheckStatesResult {
    objs: ioBroker.StateObject[];
    ids: string[];
}

export declare type ClientUnsubscribeReason = MessageUnsubscribeReason | 'clientSubscribeError';

export declare type CommandsPermissions = CommandsPermissionsObject | CommandsPermissionsEntry[];

export declare type CommandsPermissionsEntry = {
    type: 'object' | 'state' | '' | 'other' | 'file';
    operation: string;
};

export declare type CommandsPermissionsObject = {
    [permission: string]: CommandsPermissionsEntry;
};

export declare type GetCertificatesCallback = (err?: Error | null, certs?: ioBroker.Certificates, useLetsEncryptCert?: boolean) => void;

export declare type GetCertificatesPromiseReturnType = [cert: ioBroker.Certificates, useLetsEncryptCert?: boolean];

export declare type GetEncryptedConfigCallback = (error: Error | null | undefined, result?: string | string[]) => void;

export declare interface GetUserGroupsOptions {
    user: `system.user.${string}`;
    [other: string]: any;
}

export declare interface InstallNodeModuleOptions {
    /** Version of node module */
    version: string;
}

/**
 * The internal adapter config type should only be used to access config properties which are set by the adapter developers.
 * Only use it like `this.config as InternalAdapterConfig`
 */
export declare type InternalAdapterConfig = Record<string, unknown>;

/**
 * Contents of iobroker.json plus some internal variables
 */
declare interface InternalAdapterJsonConfig extends ioBroker.IoBrokerJson {
    /** Is instance started with the `--install` flag */
    isInstall?: boolean;
    /** If logs must be printed to stdout */
    consoleOutput?: boolean;
    /** Start instance even if it disabled in config */
    forceIfDisabled?: boolean;
    /** Instance number */
    instance?: number;
}

export declare interface InternalAddChannelToEnumOptions {
    enumName: string;
    addTo: string;
    parentDevice: string;
    channelName: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalAddStateToEnumOptions {
    enumName: string;
    addTo: string;
    parentDevice: string;
    parentChannel: string;
    stateName: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalCalculatePermissionsOptions {
    user: string;
    commandsPermissions: CommandsPermissions;
    options?: Record<string, any> | null;
    callback?: CalculatePermissionsCallback;
}

export declare interface InternalCheckGroupOptions {
    user: string;
    group: string;
    options?: Record<string, any> | null;
    callback?: CheckGroupCallback;
}

export declare interface InternalCheckPasswordOptions {
    user: string;
    pw: string;
    options?: Record<string, any> | null;
    callback: CheckPasswordCallback;
}

export declare interface InternalCreateDeviceOptions {
    deviceName: string;
    common?: Partial<ioBroker.DeviceCommon>;
    _native?: Record<string, any> | null;
    options: unknown;
    callback?: ioBroker.SetObjectCallback;
}

export declare interface InternalCreateStateOptions {
    parentDevice: string;
    parentChannel: string;
    stateName: string;
    common: Partial<ioBroker.StateCommon>;
    _native: Record<string, any>;
    options?: Record<string, any> | null;
    callback?: ioBroker.SetObjectCallback;
}

export declare interface InternalDeleteChannelFromEnumOptions {
    enumName: string;
    parentDevice: string;
    channelName: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDeleteChannelOptions {
    parentDevice: string;
    channelName: string;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDeleteDeviceOptions {
    deviceName: string;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDeleteStateFromEnumOptions {
    enumName: string;
    parentDevice: string;
    parentChannel: string;
    stateName: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDeleteStateOptions {
    parentDevice: string;
    parentChannel: string;
    stateName: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDelObjectOptions {
    id: string;
    options?: ioBroker.DelObjectOptions | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDelStateOptions {
    id: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalDestroySessionOptions {
    id: string;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalFormatDateOptions {
    dateObj: string | Date | number;
    isDuration: boolean;
    _format?: string;
}

export declare interface InternalGetAdapterObjectsOptions {
    callback?: (objects: Record<string, ioBroker.AdapterScopedObject>) => void;
}

export declare interface InternalGetCertificatesOptions {
    publicName?: string;
    privateName?: string;
    chainedName?: string;
    callback?: GetCertificatesCallback;
}

export declare interface InternalGetChannelsOfOptions {
    parentDevice?: string;
    callback?: ioBroker.GetObjectsCallback3<ioBroker.ChannelObject>;
    options?: Record<string, any> | null;
}

export declare interface InternalGetDevicesOptions {
    options?: Record<string, any> | null;
    callback: ioBroker.GetObjectsCallback3<ioBroker.DeviceObject>;
}

export declare interface InternalGetEncryptedConfigOptions {
    attribute: string;
    callback?: GetEncryptedConfigCallback;
}

export declare interface InternalGetEnumOptions {
    _enum: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.GetEnumCallback;
}

export declare interface InternalGetEnumsOptions {
    _enumList?: ioBroker.EnumList;
    options?: Record<string, any> | null;
    callback?: ioBroker.GetEnumsCallback;
}

export declare interface InternalGetHistoryOptions {
    id: string;
    options?: ioBroker.GetHistoryOptions | null;
    callback: ioBroker.GetHistoryCallback;
}

export declare interface InternalGetObjectOptions {
    id: string;
    options: unknown;
    callback?: ioBroker.GetObjectCallback<any>;
}

export declare interface InternalGetObjectsOptions {
    pattern: Pattern;
    type?: string;
    enums?: ioBroker.EnumList;
    options?: Record<string, any> | null;
    callback?: ioBroker.GetObjectsCallbackTyped<any>;
}

export declare interface InternalGetObjectViewOptions {
    design: string;
    search: string;
    params: ioBroker.GetObjectViewParams;
    options?: Record<string, any> | null;
    callback?: ioBroker.GetObjectViewCallback<ioBroker.AnyObject>;
}

export declare interface InternalGetPortOptions {
    port: number;
    host?: string;
    callback?: (port: number) => void;
}

export declare interface InternalGetSessionOptions {
    id: string;
    callback: ioBroker.GetSessionCallback;
}

export declare interface InternalGetStateOptions {
    id: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.GetStateCallback;
}

export declare interface InternalGetStatesOfOptions {
    parentDevice: string | null | undefined;
    parentChannel: string | null | undefined;
    options?: Record<string, any> | null;
    callback: ioBroker.GetObjectsCallback3<ioBroker.StateObject>;
}

export declare interface InternalGetStatesOptions {
    pattern: Pattern;
    options: Record<string, any>;
    callback: ioBroker.GetStatesCallback;
}

export declare interface InternalGetUserIDOptions {
    username: string;
}

export declare interface InternalInstallNodeModuleOptions extends InstallNodeModuleOptions {
    /** Name of the npm module or an installable url orking with `npm install` */
    moduleNameOrUrl: string;
}

export declare interface InternalReportDeprecationOption {
    /** Version in which this warning will throw an error instead */
    version?: string;
    /** The log line to report */
    deprecationMessage: string;
}

export declare interface InternalSendToHostOptions {
    /** if null, send to all hosts */
    hostName: string | null;
    command: string;
    message: any;
    callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo;
}

export declare interface InternalSendToOptions {
    instanceName: string;
    command: string;
    message: any;
    callback?: ioBroker.MessageCallback | ioBroker.MessageCallbackInfo;
    options?: SendToOptions;
}

export declare interface InternalSetObjectOptions {
    id: string;
    options?: Record<string, any> | null;
    obj: ioBroker.SettableObject;
    callback?: ioBroker.SetObjectCallback;
}

export declare interface InternalSetPasswordOptions {
    user: string;
    pw: string;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalSetSessionOptions {
    id: string;
    ttl: number;
    data: Record<string, any>;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalSetStateChangedOptions extends InternalSetStateOptions {
    callback?: ioBroker.SetStateChangedCallback;
}

export declare interface InternalSetStateOptions {
    id: string | ioBroker.IdObject;
    state: ioBroker.StateValue | ioBroker.SettableState;
    ack?: boolean;
    options?: Partial<GetUserGroupsOptions> | null;
    callback?: ioBroker.SetStateCallback;
}

export declare interface InternalStopParameters extends StopParameters {
    /** If mode is schedule or once */
    isPause?: boolean;
    /** If it has a restart schedule running */
    isScheduled?: boolean;
    /** If alive state should be updated, if undefined defaults to true */
    updateAliveState?: boolean;
}

export declare interface InternalSubscribeOptions {
    pattern: Pattern;
    options?: Record<string, any> | null;
    callback?: ioBroker.ErrorCallback;
}

export declare interface InternalUpdateConfigOptions {
    newConfig: Record<string, any>;
}

declare type Invoice = 'free' | (string & {});

export declare type IoPackageInstanceObject = ioBroker.StateObject | ioBroker.DeviceObject | ioBroker.ChannelObject | ioBroker.FolderObject | ioBroker.MetaObject;

/**
 * Log class for adapter.js
 *
 * It prefixes every message with the given namespace
 */
declare class Log implements ioBroker.Logger {
    private readonly namespaceLog;
    readonly level: ioBroker.LogLevel;
    private readonly logger;
    /**
     * @param namespaceLog Logging namespace to prefix
     * @param level The log level
     * @param logger logger instance
     */
    constructor(namespaceLog: string, level: ioBroker.LogLevel, logger: any);
    silly(msg: string): void;
    debug(msg: string): void;
    info(msg: string): void;
    error(msg: string): void;
    warn(msg: string): void;
}

export declare type MaybePromise = Promise<void> | void;

/** Message Callback used internally */
export declare interface MessageCallbackObject {
    /** the callback itself */
    cb: ioBroker.MessageCallback;
    /** The timestamp of the initial message */
    time: number;
    /** An optional timer, if a timeout has been specified */
    timer?: NodeJS.Timeout;
}

declare type MessageUnsubscribeReason = 'client' | 'disconnect';

/**
 * Options for the generated notification
 */
export declare interface NotificationOptions {
    /**
     * Additional context for the notification which can be used by notification processing adapters
     */
    contextData: ioBroker.NotificationContextData;
}

declare type OptionalCallback = undefined | Callback;

export declare type Pattern = string | string[];

declare type Pattern_2 = string | string[];

export declare interface SendToOptions {
    /** Method throws or calls error cb, if callback not called in time, works for single targets only */
    timeout?: number;
}

export declare interface SendToUserInterfaceClientOptions {
    /** id of the UI client, if not given send to all active clients */
    clientId?: string;
    /** data to send to the client */
    data: unknown;
}

export declare interface SetStateChangedResult {
    notChanged: boolean;
    id: string;
}

/** Two-way mapping for state quality ("q" attribute of a state) */
declare enum STATE_QUALITY {
    /** The default value for a state */
    GOOD = 0,
    /** General problem */
    BAD = 1,
    /** The instance cannot establish a connection */
    CONNECTION_PROBLEM = 2,
    /** Substitute value from controller. Do not set this in adapters */
    SUBSTITUTE_FROM_CONTROLLER = 16,
    /** Quality for default values */
    SUBSTITUTE_INITIAL_VALUE = 32,
    /** Substitute value from instance or device */
    SUBSTITUTE_DEVICE_INSTANCE_VALUE = 64,
    /** Substitute value from a sensor */
    SUBSTITUTE_SENSOR_VALUE = 128,
    /** General problem by instance */
    GENERAL_INSTANCE_PROBLEM = 17,
    /** General problem by device */
    GENERAL_DEVICE_PROBLEM = 65,
    /** General problem by sensor */
    GENERAL_SENSOR_PROBLEM = 129,
    /** The instance is not connected */
    INSTANCE_NOT_CONNECTED = 18,
    /** The device is not connected */
    DEVICE_NOT_CONNECTED = 66,
    /** The sensor is not connected */
    SENSOR_NOT_CONNECTED = 130,
    /** The device has reported an error */
    DEVICE_ERROR_REPORT = 68,
    /** The sensor has reported an error */
    SENSOR_ERROR_REPORT = 132
}

export declare interface StopParameters {
    /** Specify an optional exit code */
    exitCode?: number;
    /** Specify an optional reason for stoppage */
    reason?: string;
}

export declare interface SuitableLicense {
    /** Name of the license type, not necessarily matching adapter */
    product: string;
    /** E-Mail of a license owner */
    email: string;
    /** Unique id of this license */
    id: string;
    /** The actual license */
    json: string;
    /** If it is a free license or not */
    invoice: Invoice;
    /** The adapter instance which uses this license */
    usedBy?: string;
    /** Version for which this license is valid */
    version: string;
    /** License is only valid for given UUID */
    uuid?: string;
    /** License if valid until this date 0000-00-00 00:00:00 if unlimited */
    validTill: string;
    /** License is only valid for X number of datapoints */
    datapoints?: number;
    /** Decoded property from jwt verify on json content with cloud cert */
    decoded: {
        /** E-Mail of license owner */
        email: string;
        comment: string;
        /** License type, eg private */
        type: string;
        /** Adapter name */
        name: string;
        /** Address of license owner */
        address: {
            Country: string;
            Name: string;
            AddressLine1: string;
            AddressLine2: string;
            ZIP: string;
            City: string;
        };
        ltype: string;
        country: string;
        eu: string;
        /** VAT in percent */
        vatP: 19;
        /** Netto price information */
        netto: number;
        /** VAT price information */
        vat: number;
        /** Date when license expires */
        expires: number;
        /** How long license is valid, always in future if valid */
        valid_till: string;
        id: string;
        iat: number;
        /** Version for which this license is valid */
        version: string;
        /** License is only valid for given UUID */
        uuid?: string;
        /** If it is a free license or not */
        invoice: Invoice;
    };
}

declare const SUPPORTED_FEATURES: ("ALIAS" | "ALIAS_SEPARATE_READ_WRITE_ID" | "ADAPTER_GETPORT_BIND" | "ADAPTER_DEL_OBJECT_RECURSIVE" | "ADAPTER_SET_OBJECT_SETS_DEFAULT_VALUE" | "ADAPTER_AUTO_DECRYPT_NATIVE" | "PLUGINS" | "CONTROLLER_NPM_AUTO_REBUILD" | "CONTROLLER_READWRITE_BASE_SETTINGS" | "CONTROLLER_MULTI_REPO" | "CONTROLLER_LICENSE_MANAGER" | "CONTROLLER_OS_PACKAGE_UPGRADE" | "DEL_INSTANCE_CUSTOM" | "CUSTOM_FULL_VIEW" | "ADAPTER_GET_OBJECTS_BY_ARRAY" | "CONTROLLER_UI_UPGRADE" | "ADAPTER_WEBSERVER_UPGRADE")[];

declare type SupportedFeature = (typeof SUPPORTED_FEATURES)[number];

export declare type TimeoutCallback = (...args: any[]) => void;

export declare type UserInterfaceClientRemoveMessage = (Omit<ioBroker.Message, 'message' | 'command'> & {
    command: 'clientUnsubscribe';
    message: {
        reason: MessageUnsubscribeReason;
        type: string[];
    };
}) | (Omit<ioBroker.Message, 'message' | 'command'> & {
    command: 'clientSubscribeError';
    message: {
        reason: undefined;
        type: string[];
    };
});

export declare type UserInterfaceClientSubscribeHandler = (subscribeInfo: UserInterfaceSubscribeInfo) => UserInterfaceClientSubscribeReturnType | Promise<UserInterfaceClientSubscribeReturnType>;

export declare interface UserInterfaceClientSubscribeReturnType {
    /** If the adapter has accepted the client subscription */
    accepted: boolean;
    /** Optional heartbeat, if set, the client needs to re-subscribe every heartbeat interval */
    heartbeat?: number;
    /** Optional error if not accepted */
    error?: string;
}

export declare type UserInterfaceClientUnsubscribeHandler = (unsubscribeInfo: UserInterfaceUnsubscribeInfo) => void | Promise<void>;

declare type UserInterfaceClientUnsubscribeReason = ClientUnsubscribeReason | 'timeout';

export declare interface UserInterfaceSubscribeInfo {
    /** The client id, which can be used to send information to clients */
    clientId: string;
    /** The message used for subscription */
    message: ioBroker.Message;
}

export declare type UserInterfaceUnsubscribeInfo = UserInterfaceUnsubscribeInfoBaseObject & ({
    /** Reason for unsubscribing */
    reason: Exclude<UserInterfaceClientUnsubscribeReason, ClientUnsubscribeReason>;
    message?: undefined;
} | {
    /** Reason for unsubscribing */
    reason: ClientUnsubscribeReason;
    /** Message used for unsubscribing */
    message: ioBroker.Message;
});

declare type UserInterfaceUnsubscribeInfoBaseObject = {
    /** The handler id, which can be used to send information to clients */
    clientId: string;
};

declare interface ValidateIdOptions {
    /** in maintenance mode, we can access invalid ids to delete them, only works with the admin user */
    maintenance?: boolean;
    /** User used to check for access rights */
    user?: string;
}

export declare class Validator {
    private readonly objects;
    private readonly states;
    private readonly namespaceLog;
    private readonly log;
    private readonly namespace;
    private readonly namespaceRegExp;
    /**
     * Validator for internal adapter.js usage
     *
     * @param objects - Objects DB
     * @param states - States DB
     * @param namespaceLog - Log prefix
     * @param logger - Logger instance
     * @param namespace - the namespace of the adapter
     * @param namespaceRegExp - the namespace RegExp of the adapter `adapter.0`
     */
    constructor(objects: any, states: any, namespaceLog: string, logger: any, namespace: string, namespaceRegExp: RegExp);
    /**
     * Performs the strict object check, which includes checking object existence, read-only logic, type and min/max
     * additionally it rounds state values whose objects have a `common.step` attribute defined
     *
     * @param id - id of the state
     * @param state - ioBroker setState object
     */
    performStrictObjectCheck(id: string, state: ioBroker.SettableState): Promise<void>;
    /**
     * Checks if a passed ID is valid. Throws an error if id is invalid
     *
     * @param id id to check or object with properties device, channel and state
     * @param isForeignId true&false if the ID is a foreign/full ID or only an "adapter local" id
     * @param options optional
     * @throws Error when id is invalid
     */
    validateId(id: any, isForeignId: boolean, options?: ValidateIdOptions | null): asserts id is string;
    /**
     * Look up the error description for an error code
     *
     * @param code error code
     * @returns error description
     */
    static getErrorText(code: number): string;
    /**
     * Throws if a type is not matching the expected type
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertString(value: unknown, name: string): asserts value is string;
    /**
     * Throws if a type is not a pattern
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertPattern(value: unknown, name: string): asserts value is Pattern_2;
    /**
     * Throws if a type is not matching the expected type
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertBoolean(value: unknown, name: string): asserts value is boolean;
    /**
     * Throws if a type is not matching the expected type
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertNumber(value: unknown, name: string): asserts value is number;
    /**
     * Throws if a type is not matching the expected type
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertObject<T extends Record<string, any> = Record<string, any>>(value: unknown, name: string): asserts value is T;
    /**
     * Throws if a type is not an optional callback
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertBuffer(value: unknown, name: string): asserts value is Buffer;
    /**
     * Throws if a type is not an optional callback
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertOptionalCallback(value: unknown, name: string): asserts value is OptionalCallback;
    /**
     * Throws if a type is not an optional callback
     *
     * @param value value to check a type of
     * @param name name of the parameter for logging
     */
    static assertCallback(value: unknown, name: string): asserts value is Callback;
    /**
     * Adds the namespace to the ID if it is missing, if an object is passed it will be converted to an id string
     *
     * @param id id which will be fixed
     * @param isPattern if the id is a pattern
     */
    fixId(id: string | ioBroker.IdObject, isPattern?: boolean): string;
    /**
     * Validates the object-type argument that is passed to setState
     *
     * @param obj object to validate
     */
    validateSetStateObjectArgument(obj: Record<string, any>): void;
    /**
     * Validates that the timeout is not exceeding a 32-bit signed integer
     *
     * @param ms milliseconds to validate
     */
    static assertTimeout(ms: number): void;
}

export { }
